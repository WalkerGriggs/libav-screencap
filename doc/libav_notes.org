#+TITLE: Libav Discovery Notes
#+AUTHOR: Walker Griggs (_rubik)
#+DATE: <2022-08-21 Sun>
#+EMAIL: walker@walkgriggs.com
#+LANGUAGE: en-us

* Preface

These notes accompany the ~libav-screencap~ project. They're largely for discovery and context tracking, but also outline my learning process. If all goes well, these notes will be dropped and turned into a blog post.

** libav core concepts

*** Useful links:
  - https://libav.org/documentation/doxygen/master/group__lavu.html
  - https://libav.org/documentation/doxygen/master/group__lavu__data.html

*** Data structures

- ~AVPacket~ ([[https://libav.org/documentation/doxygen/master/structAVPacket.html#details][source]]): Part of the ~avcodec.h~ library and stores compressed data.

  This struct is often used to pass intermediary data between codecs and multiplexers (in either direction).

  In the video context, the package contains a single compressed frame. For audio, it cam contain multiple "frames".

- ~AVBuffer~ ([[https://libav.org/documentation/doxygen/master/group__lavu__buffer.html#details][source]]): Is a "reference-counted" data buffer and part of the buffer API which mainly contains the ~AVBuffer~ and ~AVBufferRef~.

  The buffer is opaque and shouldn't be accessed directly. Instead, a reference should be created. The buffer data itself will be automatically freed when the last reference is freed. A buffer is considered "writable" if there's only a single reference.

  You can allocate a new buffer or wrap an existing array in a buffer.

- ~AVFrame~ ([[https://libav.org/documentation/doxygen/master/group__lavu__frame.html#details][source]]): A frame is another abstraction for "reference-counted" multi-media data.

  A frame is essentially a wrapper for the data, which must be managed independently (often through AVBuffers). Like buffers, frames have references which should be freed.

  Frames are generally re-used.

** grabbing frames from XCB

To better understand pulling from XVFB or XCB, we first need to understand libavdevice/xcbgrab.c

There are a number of options to record smaller sections of the screen

#+begin_src C -r
static int xcbgrab_reposition(AVFormatContext *s,
                              xcb_query_pointer_reply_t *p,
                              xcb_get_geometry_reply_t *geo)
#+end_src

*** Useful links

https://xcb.freedesktop.org/manual/group__XCB____API.html

*** Grabbing a frame

Specifically ~xcbgrab_frame~

#+begin_src C -r
static int xcbgrab_frame(AVFormatContext *s, AVPacket *pkt)
#+end_src

There's a shared memory (SHM) implementation of this function (~xcbgrab_frame_shm~) which makes use of XCB's [[https://xcb.freedesktop.org/manual/group__XCB__Shm__API.html#detail][shared memory api]]. Ignoring this for now -- it's largely an implementation detail, and performance isn't an issue yet.

First step of any function, declare the relevant variables.

#+begin_src C -r
    XCBGrabContext *c = s->priv_data;
    xcb_get_image_cookie_t iq;
    xcb_get_image_reply_t *img;
    xcb_drawable_t drawable = c->window_id;
    xcb_generic_error_t *e = NULL;
    uint8_t *data;
    int length;
#+end_src

- ~XCBGrabContext~ ([[https://github.com/FFmpeg/FFmpeg/blob/master/libavdevice/xcbgrab.c#L50][source)]]: Our FFMPEG friend that's use to store state for the input device

- ~xcb_get_image_cookie_t~ ([[https://xcb.freedesktop.org/manual/structxcb__get__image__cookie__t.html][source)]]: Basically an integer which is used to identify X server requests

- ~xcb_get_image_reply_t~ ([[https://xcb.freedesktop.org/manual/structxcb__get__image__reply__t.html][source)]]: Response struct that holds relevant image data

  #+begin_src C -r
  typedef struct xcb_get_image_reply_t {
      uint8_t        response_type;
      uint8_t        depth;
      uint16_t       sequence;
      uint32_t       length;
      xcb_visualid_t visual;
      uint8_t        pad0[20];
  } xcb_get_image_reply_t;
  #+end_src

- ~xcb_drawable_t~: A boolean (~typedef uint32_t~) which indicates whether the image or window can be drawn to the screen.

- ~xcb_generic_error_t~ ([[https://xcb.freedesktop.org/manual/structxcb__generic__error__t.html][source]]): Exactly as the name implies, a generic error returned by XCB which wraps more specific error details

  #+begin_src C -r
  typedef struct {
      uint8_t   response_type;
      uint8_t   error_code;
      uint16_t sequence;
      uint32_t resource_id;
      uint16_t minor_code;
      uint8_t major_code;
      uint8_t pad0;
      uint32_t pad[5];
      uint32_t full_sequence;
  } xcb_generic_error_t;
  #+end_src

Once we get those defined, we can fire off a request to the X server for a frame image, and fetch that reply.

#+begin_src C
    iq  = xcb_get_image(c->conn, XCB_IMAGE_FORMAT_Z_PIXMAP, drawable,
                        c->x, c->y, c->width, c->height, ~0);

    img = xcb_get_image_reply(c->conn, iq, &e);
#+end_src

~iq~ here is that ~xcb_get_image_cookie~ which is a glorified unsigned integer that IDs our request.

We then follow up and ask for the request reply given that cookie. This response is that ~xcb_get_image_reply_t~ and will need to be freed later.

As always, check and handle this error. Also check to see if the image exists

With the image response in hand, we can get the image data and length. The length is necessary here so we can create a buffer for the resulting packet.

#+begin_src C -r
    data   = xcb_get_image_data(img);
    length = xcb_get_image_data_length(img);

    pkt->buf = av_buffer_create(data, length, xcbgrab_image_reply_free, img, 0);
    if (!pkt->buf) {
        free(img);
        return AVERROR(ENOMEM);
    }

    pkt->data = data;
    pkt->size = length;
#+end_src

Here, we're passing ~xcbgrab_image_reply_free~ which is a statically defined ffmpeg function to free the resulting image.

#+begin_src C -r
static void xcbgrab_image_reply_free(void *opaque, uint8_t *data)
{
    free(opaque);
}
#+end_src
